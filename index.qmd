---
title: Analyse de semis de points sur un réseau spatial avec R
subtitle: Commerces parisiens au début du XIXe s.
bibliography: bibliography.bib
link-citations: true
---
nocite: '@*'
---
format:
  rzine-html: default
lang: fr-FR
date: "2024-10-10"
authors:
  - name: Laurent Beauguitte
    affiliations:
      - name: UMR Géographie-cités
        department: CNRS
        address: 5, cours des Humanités
        city: Aubervilliers Cedex
        country: France
        postal-code: 93322
    orcid: 0000-0001-8803-6056 
    url: https://esprad.hypotheses.org/cv-com-et-publis
  - name: Julie Gravier
    affiliations:
      - name: UMR ThéMA
        department: CNRS
        address: 32 rue Mégevand
        city: Besançon Cedex       
        country: France
        postal-code: 25030
    orcid: 0000-0003-0449-6499
    url: https://thema.univ-fcomte.fr/page_personnelle/jgravier
doi: XXX
abstract: |
    L’analyse d’un semis de points sur un réseau désigne un ensemble de méthodes statistiques permettant de caractériser des événements ponctuels dans le temps et dans l’espace prenant place sur un réseau spatial planaire. Deux des sujets les plus traités dans la bibliographie sont les accidents de la circulation et les actes criminels commis dans l’espace public. Il est possible d’imaginer étudier d’autres thématiques plus ou moins ponctuelles dans le temps, qu’il s’agisse de l’offre commerciale dans un espace donné, du collage militant ou publicitaire, de la présence d’équipements dans l’espace public (bancs, toilettes), de présence de biotopes le long de cours d'eau, etc. Trois grands types de question sont généralement posés à ces données : (1) les points sont-ils significativement proches (ou éloignés) les uns des autres (étude du voisinage) ? (2) Existe-t-il des lieux où la concentration des points est notable (hot spots) ? (3) Quel modèle statistique est susceptible d’expliquer la géographie de ce semis de points ? Ces trois questions seront abordées durant la séance ÉlementR, fondée sur le package R [spatstat.linnet](https://cran.r-project.org/web/packages/spatstat.linnet/index.html) de la famille [spatstat](https://cran.r-project.org/web/packages/spatstat/index.html).
keywords: [semis de points, réseau spatial, analyse spatiale]
---

*JG: commentaires thématiques, clusters*


# Définitions et questions de recherche

L'analyse d'un semis de points sur un réseau désigne un ensemble de méthodes statistiques permettant de caractériser des événements ponctuels dans le temps et dans l'espace, appelés points dans la suite du texte, prenant place sur un réseau spatial planaire, appelé réseau ou $L$ dans la suite du texte.

Un réseau planaire est constitué par un ensemble de sommets et un ensemble de liens entre ces sommets. Tout sommet est soit une intersection soit une extrémité. Chaque sommet est composé par un couple de coordonnées, chaque lien est caractérisable par une distance. Un lien peut par ailleurs être porteur d'attributs supplémentaires. <!-- les sommets non ? -->

Deux des sujets les plus traités dans la bibliographie sont les accidents de la circulation et les actes criminels commis dans l'espace public. Dans les deux cas, des événements dramatiques pouvant être caractérisés par des attributs de types différents se produisent dans un espace pouvant être modélisé sous forme de réseau planaire (réseau routier, réseau viaire). Il est possible d'imaginer d'autres thématiques plus ou moins ponctuelles dans le temps, qu'il s'agisse de l'offre commerciale dans un espace donné, du collage militant ou publicitaire, de la présence d'équipements dans l'espace public (bancs, toilettes), de la répratition de biotopes le long d'un cours d'eau, etc.

Trois grands types de question sont généralement posées à ces données :

* les points sont-ils significativement proches (ou éloignés) les uns des autres (étude du voisinage) ?
* existe-il des lieux où la concentration des points est notable (*hot spots*) ?
* quel modèle statistique est susceptible d'expliquer la géographie de ce semis de points ?

# Le package linnet

`spatstat.linnet` est un _package_ de la famille de _packages_ `spatstat` consacré à la statistique spatiale et notamment à l'analyse de semis de points.

## Préparer ses données

La première étape consiste à créer un objet `linnet` (*linear network* ou $L$) à l'aide de deux fichiers : un fichier correspondant aux sommets (intersections et extrémités des liens), un fichier correspondant aux liens entre ces sommets. Le fichier des sommets comprend trois colonnes correspondant au nom et aux coordonnées de chaque sommet ; le fichier des liens comprend deux colonnes correspondant aux deux extrémités de chaque lien. L'orientation des liens n'est pas prise en compte : un lien *a-b* implique nécessairement un lien *b-a*, il n'est donc pas utile d'avoir deux lignes différentes.

Créer un objet `lpp` (*linear point pattern*) suppose d'ajouter à ce réseau $L$ un semis de points. Le fichier correspondant comprend au moins les coordonnées (x,y) de chacun des points, nécessairement situés sur $L$, c'est-à-dire accrochés d'un point de vue topologique ; il peut comprendre autant de colonnes supplémentaires que d'attributs, les attributs pouvant être de type différents (entiers, flottants, chaîne de caractère, booléen).

### Créer des objets `linnet` et `lpp` de A à Z et visualiser pour comprendre la structure des objets

Dans un premier temps, nous montrons comment créer les objets `linnet` à partir de ses propres données. Le mini jeu de données concerne des affichages politiques dans l'espace public. Deux fichiers sont utilisés pour créer le réseau planaire : un fichier de points et leurs coordonnées ; un fichier de liens entre ces points (liens non orientés).

```{r, warning=FALSE, message=FALSE}
#chargement des packages
# on a besoin de tout ça ?..
library(sf)
library(spatstat)
library(tibble)
library(dplyr)
library(stringr)

# import des fichiers
mini_node <- read.table(file = "data/data_mini/mini_node.txt", header = TRUE, row.names = 1, sep = ",")
mini_edge <- read.table("data/data_mini/mini_edge.txt", header = FALSE, sep = ",")

# transformation en objet ppp et matrice
mini_node_ppp <- ppp(x = mini_node$x, y = mini_node$y, c(0,10), c(0,10))
mini_edge_matrix <- as.matrix(mini_edge, ncol = 2)

mini <- linnet(vertices = mini_node_ppp, edges = mini_edge_matrix)
class(mini)
plot(mini)
```

Deux semis de points sont ensuite importés. Le premier concerne l'affichage politique et comprend les variables suivantes :

* x,y : coordonnées du collage
* nb : nombre d'affiches (entier)
* pol : tendance politique (eg : extrême-gauche, fe : féministe, ed : extrême-droite)
* sti : présence d'autocollant (0 : non, 1 : oui)

Le second semis de points concerne la présence d'équipements publics. Il est en effet probable que la présence de certains équipements facilite ou contraigne l'affichage militant. Il comprend les coordonnées (colonnes x et y) et une typologie (bus : arrêt de bus ; sub : station de métro ; ps : commissariat).

```{r}
semis_collage <- read.table("data/data_mini/mini_points1.txt", header = TRUE, sep = ",") # premier semis sur l'affichage politique

# contrôle du typage des variables
str(semis_collage)

# typage de la variable sti
semis_collage$sti <- as.logical(semis_collage$sti)

semis_equipement <- read.table("data/data_mini/mini_points2.txt", header = TRUE, sep = ",") # second semis sur les équipements publics

# transformation en semis de points sur réseau linéaire
collage_lpp <- lpp(X = semis_collage, L = mini)
equip_lpp <- lpp(X = semis_equipement, L = mini)
```

Les attributs des semis de points sont appelé `marks` dans le _package_ `spatstat.linnet`. Par défaut, la fonction `plot` crée une visualisation par attribut et la variable visuelle s'adapte au type de l'attribut. Si l'on souhaite visualiser un attribut et un seul, on utilise l'argument `which.marks`.

```{r}
plot(collage_lpp)
plot(equip_lpp, which.marks = "pol")
```

L'objectif des lignes précédentes était de montrer comment créer un objet `linnet` de A à Z. Les objets créés sont trop pauvres pour montrer l'intérêt du _package_ et, dans la suite, le jeu de données est issu du projet [SoDUCo](https://soduco.geohistoricaldata.org/). 


### Créaer et visualiser des objets depuis des données spatiales (usuelles) 
<!-- à partir de données spatiales ? -->

Les données sont dérivées <!-- issues ? --> de l'extraction des _Annuaires_ commerciaux de la ville de Paris en 1839^[Il s'agit plus précisément de l'extraction de la liste alphabétique de l'_Annuaire Général du Commerce_ édité par Charles Lamy en 1839. Les informations plus précises sont inclues dans les métadonnées du dossier _data_ (fichier _readme.md_).]. Les deux jeux de données listent les épiciers et les bijoutiers présents dans l'espace municipal à cette date.

Le code suivant permet d'importer les données et de les transformer en objet `linnet`, puis en objet `lpp`.

```{r, warning=FALSE, message=FALSE}
# import du réseau viaire parisien en 1836
paris <- st_read("data/1836_jacoubet.shp")

# import des semis de points
epiciers <- st_read(dsn = "data/grocers_1839.gpkg")
bijoutiers <- st_read(dsn = "data/jewellers_1839.gpkg")

# contrôle visuel des objets importés
plot(paris$geometry)
plot(epiciers$geom, pch = 15, col = "blue", add = TRUE)
plot(bijoutiers$geom, pch = 15, col = "red", bg = "red", add = TRUE)
```

La transformation des semis de points en objets spatstat se fait à l'aide de la fonction `as.ppp` (_planar point pattern_). Pour transformer le réseau viaire en objet `linnet`, deux étapes sont nécessaires : transformer le shapefile en objet `psp` (_planar segment pattern_) puis en objet `linnet` (_linear network_). La fonction `summary` permet de connaître les principales propriétés des objets créés.

```{r}
epiciers_ppp <- as.ppp(st_geometry(epiciers))
bijoutiers_ppp <- as.ppp(st_geometry(bijoutiers))

paris <- as.psp(st_geometry(paris))
paris <- as.linnet(paris)

summary(paris)
```

Concernant les informations sur le réseau viaire, la fonction `summary` renvoie :

* le nombre de sommets et de liens (*7237 vertices and 8730 lines*)
* la longueur totale du réseau (*total length 461193.7*)
* le degré maximal (*maximum vertex degree 7*)
* la connexité du réseau (*network is connected*)
* le diamètre (*diameter 10017.93*)
* le rayon (*bouding radius: 5058.732*)

Longueur totale, diamètre et rayon se basent sur la distance géographique sur le réseau planaire et non sur la distance topologique. Le diamètre donne donc ici la longueur en mètres, et non en nombre de liens, du plus long des plus courts chemins. De manière générale, toutes les méthodes implémentées dans `linnet` se basents sur les distances géographiques sur le réseau planaire étudié.

## Propriétés des objets `linnet` et `lpp`

Si on souhaite utiliser une mesure précise, il est possible d'obtenir ces informations avec des fonctions spécifiques :

* nombre de sommets (`nvertices`) 
* nombre de liens (`nsegments`)
* longueur totale du réseau (`volume`)
* diamètre du réseau planaire (`diameter`)
* rayon du réseau (distance entre le ou les sommets centraux et les sommets les plus périphériques) (`boundingradius`)

D'autres mesures sont également disponibles et notamment le degré de chaque sommet (`vertexdegree`).

Le code suivant montre quelques-uns des résultats obtenus à l'aide de ces fonctions.

```{r}
# nombre de sommets
nvertices(paris)

# longueur totale du réseau viaire (en mètres)
volume(paris)

# degré
mean(vertexdegree(paris))

```


Sur un objet de type `lpp` (*linear point pattern*), les principales mesures proposées sont les suivantes :

* nombre de points (`npoints`)
* nombre de points par unité de mesure (`intensity`)
* matrice des plus courtes distances entre points (`pairdist`)
* distance au plus proche voisin (`nndist`)
* identifiant du plus proche voisin (`nnwhich`)

La fonction `summary` permet là encore d'obtenir certaines de ces informations (nombre de points, nombre de points par unité), elle rappelle les caractéristiques principales du réseau (nombre de sommets, de liens et volume total) et enfin, elle fournit quartiles, médiane et moyenne des éventuels attributs numériques des points.

Le code suivant permet de calculer ces différents éléments sur le semis des épiciers et des bijoutiers à Paris.

```{r}
# semis des épiciers
# nombre de points et nombre de points par mètre
npoints(epiciers_ppp)
intensity(epiciers_ppp)

# plus court chemin (géographique et non topologique) entre paires de points
pairdist(epiciers_ppp)[1:5, 1:5]

# distance géographique au plus court voisin
nndist(epiciers_ppp)[1:5] 

# identifiant du plus proche voisin
nnwhich(epiciers_ppp)[1:5] 

# semis des bijouteries
npoints(bijoutiers_ppp)
intensity(bijoutiers_ppp)
```

La dernière étape consiste à intégrer dans le même objet le réseau linéaire et le semis de points à l'aide de la fonction `lpp`.

```{r}
epiciers_lpp <- lpp(X = epiciers_ppp, L = paris)
summary(epiciers_lpp)

bijoutiers_lpp <- lpp(X = bijoutiers_ppp, L = paris)
summary(bijoutiers_lpp)
```

*Faire les mesures pour les deux semis et proposer un court commentaire thématique ?*

<!-- inutile car vu sur le mini jeu de données  - Si l'on exécute la fonction `plot` sur un objet `lpp`, par défaut `linnet` propose un nombre de visualisations égal au nombre d'attributs des points, ces attributs étant appelés `marks`. Si je souhaite visualiser la répartion d'un attribut *Z* donné , j'utilise la syntaxe `plot(X, which.marks='Z')` -- le jeu de données utilisés ne comportant pas d'attributs pour les semis de points, cette option n'est pas mise en oeuvre ici. -->

La visualisation de certaines mesures est intégrée par défaut dans le *package* et c'est notamment le cas pour la densité (nombre de points par unité de mesure du réseau).

```{r}
par(mfrow=c(1,2))

# calcul de la densité de points par unité de réseau
# l'option finespacing n'est pas nécessaire pour un réseau de petite taille
densite_bij <- density(x = bijoutiers_lpp, finespacing = FALSE)
densite_epic <- density(epiciers_lpp, finespacing = FALSE)

# option couleur (par défaut)
plot(densite_epic)

# option épaisseur des liens du réseau
plot(x = densite_bij, 
     main = "Densité de bijoutiers",
     style = "width", 
     adjust = 0.5)  # contrôler épaisseur max
```


Il est possible d'étudier un semis de points sur réseau spatial selon les mêmes logiques qu'un semis dans un espace isotrope car diverses mesures ont été adaptées afin de considérer la structure du réseau [voir en particulier @okabe2012]. <!-- je ne comprends pas, trop allusif je crois -->

# Étudier les voisinages

Différences d'approche entre fonction K et méthode du plus proche voisin

Questions selon qu'on étudie un ou deux semis de points


## Analyser un semis de points

Fonctions: 

linearK (plus court chemin) et linearKinhom (pcc et non homogène)

linearKEuclid (distance euclidienne), linearKEuclidInhom (distance euclidienne et non homogène)

## Analyser la relation entre deux semis de points

```{r}
# étudier un semis par rapport à un autre

crossdist(epiciers_ppp, bijoutiers_ppp)[1:5, 1:5] # shortest-path distances between pairs of ‘things’ taken from two different datasets.

nncross(epiciers_ppp, bijoutiers_ppp)[1:5,]  # given two point patterns X and Y, finds the nearest neighbour in Y of each point of X.
```

Fonctions: linearKcross, linearKdot

# Modéliser la géographie du semis de points

## Répartitions aléatoires des points sur un réseau spatial

Il est possible de comparer la répartition du semis de points étudié par rapport à une situation aléatoire sur un réseau. Plusieurs processus aléatoires peuvent être simulés dans `spatstat.linnet` :

<!-- ok mais expliquer la différence entre les 3-->

* Un processus poissonien avec la fonction `rpoislpp()`. Elle génère une réalisation du processus de Poisson avec une intensité spécifiée (paramètre `lambda`) sur le réseau $L$.
* Un processus aléatoire uniforme avec `runiflpp()`. La fonction génère $n$ points aléatoires, indépendamment et uniformément distribués, sur le réseau $L$. La probabilité de tirer un tronçon $Ls$ du réseau dépend de sa longueur dans $L$. Le point est généré selon une probabilité uniforme le long de $Ls$.
* Un processus aléatoire grâce à `rlpp()`, qui génère $n$ points aléatoires sur le réseau $L$ avec une densité de probabilité spécifié (paramètre `f`). Cette dernière ne doit pas nécessairement être normalisée.

Dans les cas de `rpoislpp()` et de `runiflpp()`, le paramètre `ex` permet d'intégrer un objet `lpp` afin de déterminer $L$, ainsi que $\lambda$ et $n$. La valeur par défaut de $\lambda$ est alors la densité moyenne des points du `lpp`, ou $n$ le nombre de points de l'objet `lpp`. Quelle que soit la fonction utilisée, il est possible de spécifier le nombre de simulations souhaitées grâce au paramètre `nsim`.

```{r}
# génération d'une simulation selon un processus aléatoire uniforme et visualisation
plot(runiflpp(n = bijoutiers_ppp$n, # nombre de bijoutiers
         L = paris),
     pch = 15, main = NULL)

# génération de 2 simulations
process_al_2sim <- runiflpp(n = bijoutiers_ppp$n, # nombre de bijoutiers
         L = paris, nsim = 2)

process_al_2sim[1]

# visualisation
par(mfrow = c(1,2))
for (i in 1:length(process_al_2sim)) {
  plot(process_al_2sim[[i]], pch = 15, cex = 0.5, main = paste("Simulation ", i))
}
```

## Mesurer l'écart aux distributions aléatoires

Cas des bijoutiers, distances points aléatoires VS distances observées
```{r, warning=FALSE}
# génération de 20 simulations
bijoutiers_20sim <- runiflpp(ex = bijoutiers_lpp, nsim = 20)

# calcul des distances entre les points simulés aléatoirement sur le réseau
list_simulated_dist <- list()

for (i in 1:length(bijoutiers_20sim)) { # proposition d'une boucle à visée pédagogique et non d'une fonction + parallélisation
    # calculs des plus courts chemins sur réseau
    dist_pi_p <- spatstat.geom::pairdist(X = bijoutiers_20sim[[i]])
    dist_pi_p[upper.tri(x = dist_pi_p, diag = TRUE)] <- NA
    
    dist_pi_p <- dist_pi_p %>%
      tibble::as_tibble() %>%
      tibble::rowid_to_column(var = "Pi") %>%
      tidyr::pivot_longer(cols = -Pi, names_to = "P", values_to = "dist_pi_p") %>%
      dplyr::filter(!is.na(dist_pi_p)) %>%
      dplyr::mutate(P = stringr::str_replace_all(string = P, pattern = "V", replacement = "")) %>%
      dplyr::mutate(type = "simulation", n_sim = i)
      
   list_simulated_dist[[i]] <- dist_pi_p   
}

# création d'un unique tableau et non d'une liste de tableaux
table_simulated_dist <- do.call(what = "rbind", args = list_simulated_dist)
table_simulated_dist

# calcul

```


Idem, cas des épiciers
```{r}
# génération de 100 simulations
epiciers_100sim <- runiflpp(ex = epiciers_lpp, nsim = 100)
```


## Rechercher et analyser les clusters


# Intérêts et limites du package

# Pour aller plus loin

Le manuel le plus complet et le plus clair concernant l'analyse de semis de points sur un réseau est celui d'Okabe et Sugihara [-@okabe2012] ; toutes les méthodes abordées par les auteurs ne peuvent être mises en oeuvre avec `linnet` (autocorrélation spatiale, modèle de Huff, etc.). L'article de Baddeley et Turner consacré à la première version du *package* [-@baddeley2005] gagne à être complété par le chapitre 17 de l'ouvrage de Baddeley *et al.* [-@baddeley2012]. À compléter par une mise à jour bibliographique récente co-signé du même Baddeley [-@baddeley2021].

Note : à voir, densité de Kernel sur réseau dans [-@okabe2009]
