<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr-FR" xml:lang="fr-FR"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="keywords" content="semis de points, réseau spatial, analyse spatiale">

<title>Analyse de semis de points sur un réseau spatial avec R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #f0aa0c;
      }

      .quarto-title-block .quarto-title-banner {
        color: #f0aa0c;
background: #0c3762;
      }
</style>
<style>
h1 {
color: #f0aa0c;
}
</style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="_extensions/rzine-reviews/rzine/styles.css">
</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Analyse de semis de points sur un réseau spatial avec R</h1>
            <p class="subtitle lead">Commerces parisiens au début du XIXe siècle</p>
                      </div>
  </div>
    
  <div class="quarto-title-meta-author">
    <div class="quarto-title-meta-heading">Auteur·rice·s</div>
    <div class="quarto-title-meta-heading">Affiliations</div>
    
      <div class="quarto-title-meta-contents">
      <p class="author"><a href="https://esprad.hypotheses.org/cv-com-et-publis">Laurent Beauguitte</a> <a href="https://orcid.org/0000-0001-8803-6056" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
    </div>
    <div class="quarto-title-meta-contents">
          <p class="affiliation">
              UMR Géographie-cités
            </p>
        </div>
      <div class="quarto-title-meta-contents">
      <p class="author"><a href="https://thema.univ-fcomte.fr/page_personnelle/jgravier">Julie Gravier</a> <a href="https://orcid.org/0000-0003-0449-6499" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
    </div>
    <div class="quarto-title-meta-contents">
          <p class="affiliation">
              UMR ThéMA
            </p>
        </div>
    </div>

  <div class="quarto-title-meta">

        
      <div>
      <div class="quarto-title-meta-heading">Date de publication</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2025-05</p>
      </div>
    </div>
    
      
      <div>
      <div class="quarto-title-meta-heading">Doi</div>
      <div class="quarto-title-meta-contents">
        <p class="doi">
          <a href="https://doi.org/XXX">XXX</a>
        </p>
      </div>
    </div>
    </div>
    
  <div>
    <div class="abstract">
      <div class="block-title">Résumé</div>
      <p>L’analyse d’un semis de points sur un réseau désigne un ensemble de méthodes statistiques permettant de caractériser des événements ponctuels dans le temps et dans l’espace prenant place sur un réseau spatial planaire. Deux des sujets les plus traités dans la bibliographie sont les accidents de la circulation et les actes criminels commis dans l’espace public. Il est possible d’imaginer étudier d’autres thématiques plus ou moins ponctuelles dans le temps, qu’il s’agisse de l’offre commerciale dans un espace donné, du collage militant ou publicitaire, de la présence d’équipements dans l’espace public (bancs, toilettes), de présence de biotopes le long de cours d’eau, etc. Trois grands types de question sont généralement posés à ces données : (1) les points sont-ils significativement proches (ou éloignés) les uns des autres (étude du voisinage) ? (2) Existe-t-il des lieux où la concentration des points est notable (hot spots) ? (3) Quel modèle statistique est susceptible d’expliquer la géographie de ce semis de points ? Ces trois questions sont abordées à l’aide du package R <a href="https://cran.r-project.org/web/packages/spatstat.linnet/index.html">spatstat.linnet</a> de la famille <a href="https://cran.r-project.org/web/packages/spatstat/index.html">spatstat</a>.</p>
    </div>
  </div>

  <div>
    <div class="keywords">
      <div class="block-title">Mots clés</div>
      <p>semis de points, réseau spatial, analyse spatiale</p>
    </div>
  </div>
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table des matières</h2>
   
  <ul>
  <li><a href="#définitions-et-questions-de-recherche" id="toc-définitions-et-questions-de-recherche" class="nav-link active" data-scroll-target="#définitions-et-questions-de-recherche">Définitions et questions de recherche</a></li>
  <li><a href="#le-package-linnet" id="toc-le-package-linnet" class="nav-link" data-scroll-target="#le-package-linnet">Le package linnet</a>
  <ul class="collapse">
  <li><a href="#préparer-ses-données" id="toc-préparer-ses-données" class="nav-link" data-scroll-target="#préparer-ses-données">Préparer ses données</a>
  <ul class="collapse">
  <li><a href="#créer-des-objets-linnet-et-lpp-de-a-à-z-et-visualiser-pour-comprendre-la-structure-des-objets" id="toc-créer-des-objets-linnet-et-lpp-de-a-à-z-et-visualiser-pour-comprendre-la-structure-des-objets" class="nav-link" data-scroll-target="#créer-des-objets-linnet-et-lpp-de-a-à-z-et-visualiser-pour-comprendre-la-structure-des-objets">Créer des objets <code>linnet</code> et <code>lpp</code> de A à Z et visualiser pour comprendre la structure des objets</a></li>
  <li><a href="#créer-et-visualiser-des-objets-depuis-des-données-spatiales" id="toc-créer-et-visualiser-des-objets-depuis-des-données-spatiales" class="nav-link" data-scroll-target="#créer-et-visualiser-des-objets-depuis-des-données-spatiales">Créer et visualiser des objets depuis des données spatiales</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#étudier-les-voisinages" id="toc-étudier-les-voisinages" class="nav-link" data-scroll-target="#étudier-les-voisinages">Étudier les voisinages</a>
  <ul class="collapse">
  <li><a href="#analyser-un-semis-de-points" id="toc-analyser-un-semis-de-points" class="nav-link" data-scroll-target="#analyser-un-semis-de-points">Analyser un semis de points</a></li>
  </ul></li>
  <li><a href="#modéliser-la-géographie-du-semis-de-points" id="toc-modéliser-la-géographie-du-semis-de-points" class="nav-link" data-scroll-target="#modéliser-la-géographie-du-semis-de-points">Modéliser la géographie du semis de points</a>
  <ul class="collapse">
  <li><a href="#répartitions-aléatoires-des-points-sur-un-réseau-spatial" id="toc-répartitions-aléatoires-des-points-sur-un-réseau-spatial" class="nav-link" data-scroll-target="#répartitions-aléatoires-des-points-sur-un-réseau-spatial">Répartitions aléatoires des points sur un réseau spatial</a></li>
  <li><a href="#mesurer-lécart-aux-distributions-aléatoires" id="toc-mesurer-lécart-aux-distributions-aléatoires" class="nav-link" data-scroll-target="#mesurer-lécart-aux-distributions-aléatoires">Mesurer l’écart aux distributions aléatoires</a></li>
  <li><a href="#rechercher-et-analyser-les-clusters" id="toc-rechercher-et-analyser-les-clusters" class="nav-link" data-scroll-target="#rechercher-et-analyser-les-clusters">Rechercher et analyser les clusters</a></li>
  </ul></li>
  <li><a href="#intérêts-et-limites-du-package" id="toc-intérêts-et-limites-du-package" class="nav-link" data-scroll-target="#intérêts-et-limites-du-package">Intérêts et limites du package</a></li>
  <li><a href="#pour-aller-plus-loin" id="toc-pour-aller-plus-loin" class="nav-link" data-scroll-target="#pour-aller-plus-loin">Pour aller plus loin</a></li>
  <li><a href="#bibliography" id="toc-bibliography" class="nav-link" data-scroll-target="#bibliography">Bibliographie</a></li>
  </ul>
</nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>nocite: ‘<span class="citation" data-cites="*"></span>’</p>
<section id="définitions-et-questions-de-recherche" class="level1">
<h1>Définitions et questions de recherche</h1>
<p>L’analyse d’un semis de points sur un réseau désigne un ensemble de méthodes statistiques permettant de caractériser des événements ponctuels dans le temps et dans l’espace, appelés points dans la suite du texte, prenant place sur un réseau spatial planaire, appelé réseau ou <span class="math inline">L</span> dans la suite du texte.</p>
<p>Un réseau planaire est constitué par un ensemble de sommets et un ensemble de liens entre ces sommets. Tout sommet est soit une intersection entre deux liens, soit l’extrémité d’un lien. Chaque sommet est défini par un couple de coordonnées, chaque lien est caractérisé par une distance. Un lien peut par ailleurs être porteur d’attributs supplémentaires (largeur, intensité, etc.). En géographie, les réseaux de transport terrestres, les réseaux viaires et les réseaux hydrographiques sont généralement modélisés sous forme de graphes planaires. <!-- les sommets non ? --></p>
<p>Deux des sujets les plus traités dans la bibliographie sont les accidents de la circulation et les actes criminels commis dans l’espace public. Dans les deux cas, des événements dramatiques pouvant être caractérisés par des attributs de types différents se produisent dans un espace pouvant être modélisé sous forme de réseau planaire (réseau routier, réseau viaire). Il est possible d’imaginer d’autres thématiques plus ou moins ponctuelles dans le temps, qu’il s’agisse de l’offre commerciale dans un espace donné, du collage militant ou publicitaire, de la présence d’équipements dans l’espace public (bancs, toilettes), de la répartition de biotopes le long d’un cours d’eau, etc.</p>
<p>Trois grands types de question sont généralement posées à ces données :</p>
<ul>
<li>les points sont-ils significativement proches (ou éloignés) les uns des autres (étude du voisinage) ?</li>
<li>existe-il des lieux où la concentration des points est notable (<em>hot spots</em>) ?</li>
<li>quel modèle statistique est susceptible d’expliquer la géographie de ce semis de points ?</li>
</ul>
</section>
<section id="le-package-linnet" class="level1">
<h1>Le package linnet</h1>
<p><code>spatstat.linnet</code> est un <em>package</em> de la famille de <em>packages</em> <code>spatstat</code> consacré à la statistique spatiale et notamment à l’analyse de semis de points.</p>
<section id="préparer-ses-données" class="level2">
<h2 class="anchored" data-anchor-id="préparer-ses-données">Préparer ses données</h2>
<p>La première étape consiste à créer un objet <code>linnet</code> (<em>linear network</em> ou <span class="math inline">L</span>) à l’aide de deux fichiers : un fichier correspondant aux sommets (intersections et extrémités des liens), un fichier correspondant aux liens entre ces sommets. Le fichier des sommets comprend trois colonnes correspondant à l’identifiant et aux coordonnées de chaque sommet ; le fichier des liens comprend <em>a minima</em> deux colonnes correspondant aux deux extrémités de chaque lien. L’orientation des liens n’est pas prise en compte : un lien <em>a-b</em> implique nécessairement un lien <em>b-a</em>, il n’est donc pas utile d’avoir deux lignes différentes.</p>
<p>Créer un objet <code>lpp</code> (<em>linear point pattern</em>) suppose d’ajouter à ce réseau <span class="math inline">L</span> un semis de points. Le fichier correspondant comprend au moins les coordonnées (x,y) de chacun des points, nécessairement situés sur <span class="math inline">L</span>, c’est-à-dire accrochés d’un point de vue topologique ; il peut comprendre autant de colonnes supplémentaires que d’attributs, les attributs pouvant être de types différents (entiers, flottants, chaîne de caractère, booléen). Si les coordonnées d’un sommet de ce semis de points sont situées en dehors du réseau planaire <span class="math inline">L</span>, le package accroche par défaut le sommet en question au lien le plus proche. Aucun avertissement n’est affiché par le package.</p>
<section id="créer-des-objets-linnet-et-lpp-de-a-à-z-et-visualiser-pour-comprendre-la-structure-des-objets" class="level3">
<h3 class="anchored" data-anchor-id="créer-des-objets-linnet-et-lpp-de-a-à-z-et-visualiser-pour-comprendre-la-structure-des-objets">Créer des objets <code>linnet</code> et <code>lpp</code> de A à Z et visualiser pour comprendre la structure des objets</h3>
<p>Dans un premier temps, nous montrons comment créer les objets <code>linnet</code> à partir de ses propres données. Le mini jeu de données concerne des affichages politiques dans l’espace public. Deux fichiers sont utilisés pour créer le réseau planaire : un fichier de points et leurs coordonnées ; un fichier de liens entre ces points (liens non orientés). Le dernier point de ce dernier fichier est volontairement situé hors du réseau planaire.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#chargement des packages</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spatstat)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tibble)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># import des fichiers</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>mini_node <span class="ot">&lt;-</span> <span class="fu">read.table</span>(<span class="at">file =</span> <span class="st">"data/data_mini/mini_node.txt"</span>, </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                        <span class="at">header =</span> <span class="cn">TRUE</span>, </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                        <span class="at">row.names =</span> <span class="dv">1</span>, </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                        <span class="at">sep =</span> <span class="st">","</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>mini_edge <span class="ot">&lt;-</span> <span class="fu">read.table</span>(<span class="st">"data/data_mini/mini_edge.txt"</span>, </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                        <span class="at">header =</span> <span class="cn">FALSE</span>, </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                        <span class="at">sep =</span> <span class="st">","</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># transformation en objet ppp et matrice</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>mini_node_ppp <span class="ot">&lt;-</span> <span class="fu">ppp</span>(<span class="at">x =</span> mini_node<span class="sc">$</span>x, </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>                     <span class="at">y =</span> mini_node<span class="sc">$</span>y, </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>                     <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">10</span>), <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">10</span>))   <span class="co"># coordonnées de la fenêtre graphique</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>mini_edge_matrix <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(mini_edge, </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>                              <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>mini <span class="ot">&lt;-</span> <span class="fu">linnet</span>(<span class="at">vertices =</span> mini_node_ppp, </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>               <span class="at">edges =</span> mini_edge_matrix)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="fu">class</span>(mini)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "linnet" "list"  </code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(mini)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-1-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Un semis de points est ensuite importé. Il concerne l’affichage politique et comprend les variables suivantes :</p>
<ul>
<li>x,y : coordonnées du collage</li>
<li>nb : nombre d’affiches (entier)</li>
<li>pol : tendance politique (eg : extrême-gauche, fe : féministe, ed : extrême-droite)</li>
<li>sti : présence d’autocollant (0 : non, 1 : oui)</li>
</ul>
<p>Il est fréquent lorsqu’on récolte des donnnées ponctuelles que les coordonnées ne correspondent pas exactement au tracé viaire. Dans ce jeu de données, la dernière ligne concerne un point décalé d’une unité par rapport à la voie la plus proche. Le package <code>linnet</code>, par défaut, attribue ces points au segment le plus proche. Si le point est équidistant de deux segments, le package semble par défaut attribuer le point au segment le plus court. Il est donc prudent de contrôler soigneusement ses données avant toute manipulation.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># semis sur l'affichage politique</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>semis_collage <span class="ot">&lt;-</span> <span class="fu">read.table</span>(<span class="st">"data/data_mini/mini_points.txt"</span>, </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                            <span class="at">header =</span> <span class="cn">TRUE</span>, </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                            <span class="at">sep =</span> <span class="st">","</span>) </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># contrôle du typage des variables</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(semis_collage)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   7 obs. of  5 variables:
 $ x  : num  1 2.8 3 3 3 4.5 7
 $ y  : num  1.5 1 2.8 3.2 5 6 3
 $ nb : int  5 4 1 1 1 2 1
 $ pol: chr  "eg" "eg" "fe" "fe" ...
 $ sti: int  0 1 0 0 0 1 0</code></pre>
</div>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># typage de la variable sti</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>semis_collage<span class="sc">$</span>sti <span class="ot">&lt;-</span> <span class="fu">as.logical</span>(semis_collage<span class="sc">$</span>sti)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># transformation en semis de points sur réseau linéaire</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>collage_lpp <span class="ot">&lt;-</span> <span class="fu">lpp</span>(<span class="at">X =</span> semis_collage, </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>                   <span class="at">L =</span> mini)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Les attributs des semis de points sont appelé <code>marks</code> dans le <em>package</em> <code>spatstat.linnet</code>. Par défaut, la fonction <code>plot</code> crée une visualisation par attribut et la variable visuelle s’adapte au type de l’attribut. Si l’on souhaite visualiser un attribut et un seul, on utilise l’argument <code>which.marks</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(collage_lpp)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-3-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(collage_lpp, </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>     <span class="at">which.marks =</span> <span class="st">"nb"</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-3-2.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>La fonction <code>summary</code> permet d’obtenir des mesures basiques sur le réseau viaire et sur le semis de points.</p>
<p>Concernant les informations sur le réseau viaire, la fonction <code>summary</code> renvoie :</p>
<ul>
<li>le nombre de sommets et de liens (<em>8 vertices and 9 lines</em>)</li>
<li>la longueur totale du réseau (<em>total length 25 units</em>)</li>
<li>le degré maximal (<em>maximum vertex degree 3</em>)</li>
<li>la connexité du réseau (<em>network is connected</em>)</li>
<li>le diamètre (<em>diameter 11</em>)</li>
<li>le rayon (<em>bouding radius: 8</em>)</li>
</ul>
<p>Il est possible d’obtenir ces mesures individuellement à l’aide de fonctions spécifiques, que ce soit le nombre de sommets (<code>nvertices</code>), la longueur totale du réseau planaire (<code>volume</code>) ou le degré (<code>vertexdegree</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(mini)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Linear network with 8 vertices and 9 lines
Total length 25 units
Maximum vertex degree: 3
[Non-sparse matrix representation]
Network is connected
Diameter: 11 units
Bounding radius: 8 units
Numerical tolerance: 0.002 units
Enclosing window: rectangle = [0, 10] x [0, 10] units</code></pre>
</div>
</div>
<p>Longueur totale, diamètre et rayon se basent sur la distance géographique (exprimée en unités de mesure) sur le réseau planaire et non sur la distance topologique (nombre de liens). Le diamètre donne donc ici la longueur en unités du plus long des plus courts chemins. De manière générale, toutes les méthodes implémentées dans <code>linnet</code> se basent sur les distances géographiques sur le réseau planaire étudié.</p>
<p>La fonction <code>summary</code> appliquée à un semis de points renvoie quant à elle les informations suivantes : propriétés de base du réseau planaire (nombre de sommets, de liens et longueur totale), nombre de points (7), intensité moyenne (<em>average intensity</em>, nombre de points par unité de mesure) et la distribution des éventuels attributs numériques et booléens.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(collage_lpp)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Marked point pattern on linear network
7 points
Linear network with 8 vertices and 9 lines
Total length 25 units
Average intensity 0.28 points per unit length
Mark variables: nb, pol, sti
Summary of marks:
hyperframe with 7 rows and 3 columns
       nb            pol               sti         
 (integer)       (character)        (logical)      
 Min.   :1.000   Length:7           Mode :logical  
 1st Qu.:1.000   Class :character   FALSE:5        
 Median :1.000   Mode  :character   TRUE :2        
 Mean   :2.143                                     
 3rd Qu.:3.000                                     
 Max.   :5.000                                     
Enclosing window: rectangle = [0, 10] x [0, 10] units</code></pre>
</div>
</div>
<p>Les principales mesures proposées pour caractériser un semis de points sont les suivantes :</p>
<ul>
<li>nombre de points (<code>npoints</code>)</li>
<li>nombre de points par unité de mesure (<code>intensity</code>)</li>
<li>matrice des plus courtes distances entre points (<code>pairdist</code>)</li>
<li>distance au plus proche voisin (<code>nndist</code>)</li>
<li>identifiant du plus proche voisin (<code>nnwhich</code>)</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">npoints</span>(collage_lpp)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 7</code></pre>
</div>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">intensity</span>(collage_lpp)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.28</code></pre>
</div>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pairdist</span>(collage_lpp)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4] [,5] [,6] [,7]
[1,]  0.0  2.3  3.7  3.7  5.5  8.0  7.5
[2,]  2.3  0.0  2.0  2.4  4.2  6.7  5.2
[3,]  3.7  2.0  0.0  0.4  2.2  4.7  6.8
[4,]  3.7  2.4  0.4  0.0  1.8  4.3  7.2
[5,]  5.5  4.2  2.2  1.8  0.0  2.5  7.0
[6,]  8.0  6.7  4.7  4.3  2.5  0.0  4.5
[7,]  7.5  5.2  6.8  7.2  7.0  4.5  0.0</code></pre>
</div>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">nndist</span>(collage_lpp)[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>] </span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2.3 2.0 0.4 0.4 1.8</code></pre>
</div>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">nnwhich</span>(collage_lpp)[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>] </span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2 3 4 3 4</code></pre>
</div>
</div>
<p>L’objectif des lignes précédentes était de montrer comment créer un objet <code>linnet</code> de A à Z et de présenter les mesures de base. Les objets créés sont cependant trop pauvres pour justifier des traitements plus avancés et, dans la suite du texte, le jeu de données est issu du projet <a href="https://soduco.geohistoricaldata.org/">SoDUCo</a>.</p>
<!-- faire mesures de base ici puis modèles stats sur gros jeu. si point hors fenêtre, warning:  1 point was rejected as lying outside the specified window -->
</section>
<section id="créer-et-visualiser-des-objets-depuis-des-données-spatiales" class="level3">
<h3 class="anchored" data-anchor-id="créer-et-visualiser-des-objets-depuis-des-données-spatiales">Créer et visualiser des objets depuis des données spatiales</h3>
<!-- à partir de données spatiales ? -->
<p>Les données sont dérivées <!-- issues ? --> de l’extraction des <em>Annuaires</em> commerciaux de la ville de Paris en 1839<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Les deux jeux de données listent les épiciers et les bijoutiers présents dans l’espace municipal à cette date.</p>
<p>Le code suivant permet d’importer les données et de les transformer en objet <code>linnet</code>, puis en objet <code>lpp</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import du réseau viaire parisien en 1836</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>paris <span class="ot">&lt;-</span> <span class="fu">st_read</span>(<span class="st">"data/1836_jacoubet.shp"</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Reading layer `1836_jacoubet' from data source 
  `D:\jgravier\Sync\publications\linnet_point_pattern\data\1836_jacoubet.shp' 
  using driver `ESRI Shapefile'
Simple feature collection with 4266 features and 2 fields
Geometry type: LINESTRING
Dimension:     XY
Bounding box:  xmin: 647640.1 ymin: 6859014 xmax: 656138.1 ymax: 6865167
Projected CRS: RGF93 Lambert 93</code></pre>
</div>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import des semis de points</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>epiciers <span class="ot">&lt;-</span> <span class="fu">st_read</span>(<span class="at">dsn =</span> <span class="st">"data/grocers_1839.gpkg"</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Reading layer `grocers_1839' from data source 
  `D:\jgravier\Sync\publications\linnet_point_pattern\data\grocers_1839.gpkg' 
  using driver `GPKG'
Simple feature collection with 1028 features and 3 fields
Geometry type: POINT
Dimension:     XY
Bounding box:  xmin: 648447.8 ymin: 6859096 xmax: 655618 ymax: 6865142
Projected CRS: +proj=lcc +lat_0=46.5 +lon_0=3 +lat_1=49 +lat_2=44 +x_0=700000 +y_0=6600000 +ellps=GRS80 +units=m +no_defs</code></pre>
</div>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>bijoutiers <span class="ot">&lt;-</span> <span class="fu">st_read</span>(<span class="at">dsn =</span> <span class="st">"data/jewellers_1839.gpkg"</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Reading layer `jewellers_1839' from data source 
  `D:\jgravier\Sync\publications\linnet_point_pattern\data\jewellers_1839.gpkg' 
  using driver `GPKG'
Simple feature collection with 341 features and 3 fields
Geometry type: POINT
Dimension:     XY
Bounding box:  xmin: 648631.2 ymin: 6860188 xmax: 654177.7 ymax: 6865008
Projected CRS: +proj=lcc +lat_0=46.5 +lon_0=3 +lat_1=49 +lat_2=44 +x_0=700000 +y_0=6600000 +ellps=GRS80 +units=m +no_defs</code></pre>
</div>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># contrôle visuel des objets importés</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(paris<span class="sc">$</span>geometry)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(epiciers<span class="sc">$</span>geom, </span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>     <span class="at">pch =</span> <span class="dv">15</span>, </span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>     <span class="at">col =</span> <span class="st">"blue"</span>, </span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>     <span class="at">add =</span> <span class="cn">TRUE</span>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(bijoutiers<span class="sc">$</span>geom, </span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>     <span class="at">pch =</span> <span class="dv">15</span>, </span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>     <span class="at">col =</span> <span class="st">"red"</span>, </span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>     <span class="at">bg =</span> <span class="st">"red"</span>, </span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>     <span class="at">add =</span> <span class="cn">TRUE</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-7-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>La transformation des semis de points en objets spatstat se fait à l’aide de la fonction <code>as.ppp</code> (<em>planar point pattern</em>). Pour transformer le réseau viaire en objet <code>linnet</code>, deux étapes sont nécessaires : transformer le shapefile en objet <code>psp</code> (<em>planar segment pattern</em>) puis en objet <code>linnet</code> (<em>linear network</em>). La fonction <code>summary</code> permet de connaître les principales propriétés des objets créés (les longueurs sont ici exprimées en mètres).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>epiciers_ppp <span class="ot">&lt;-</span> <span class="fu">as.ppp</span>(<span class="fu">st_geometry</span>(epiciers))</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>bijoutiers_ppp <span class="ot">&lt;-</span> <span class="fu">as.ppp</span>(<span class="fu">st_geometry</span>(bijoutiers))</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>paris <span class="ot">&lt;-</span> <span class="fu">as.psp</span>(<span class="fu">st_geometry</span>(paris))</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>paris <span class="ot">&lt;-</span> <span class="fu">as.linnet</span>(paris)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(paris)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Linear network with 7237 vertices and 8730 lines
Total length 461193.7 units
Maximum vertex degree: 7
[Non-sparse matrix representation]
Network is connected
Diameter: 10017.93 units
Bounding radius: 5058.732 units
Numerical tolerance: 1.673106e-07 units
Enclosing window: rectangle = [647640.1, 656138.1] x [6859014, 6865167] units</code></pre>
</div>
</div>
<!--Concernant les informations sur le réseau viaire, la fonction `summary` renvoie -->
<!--* le nombre de sommets et de liens (*7237 vertices and 8730 lines*)
* la longueur totale du réseau (*total length 461193.7*)
* le degré maximal (*maximum vertex degree 7*)
* la connexité du réseau (*network is connected*)
* le diamètre (*diameter 10017.93*)
* le rayon (*bouding radius: 5058.732*)

Longueur totale, diamètre et rayon se basent sur la distance géographique (exprimée en mètres) sur le réseau planaire et non sur la distance topologique (nombre de liens). Le diamètre donne donc ici la longueur en mètres du plus long des plus courts chemins. De manière générale, toutes les méthodes implémentées dans `linnet` se basents sur les distances géographiques sur le réseau planaire étudié.-->
<!--## Propriétés des objets `linnet` et `lpp`-->
<!-- pas besoin: vu sur petit jeu -->
<!--Si on souhaite utiliser une mesure précise, il est possible d'obtenir ces informations avec des fonctions spécifiques :

* nombre de sommets (`nvertices`) 
* nombre de liens (`nsegments`)
* longueur totale du réseau (`volume`)
* diamètre du réseau planaire (`diameter`)
* rayon du réseau (distance entre le ou les sommets centraux et les sommets les plus périphériques) (`boundingradius`)

D'autres mesures sont également disponibles et notamment le degré de chaque sommet (`vertexdegree`).

Le code suivant montre quelques-uns des résultats obtenus à l'aide de ces fonctions.
# nombre de sommets
nvertices(paris)
# longueur totale du réseau viaire (en mètres)
volume(paris)
# degré moyen
mean(vertexdegree(paris))

Sur un objet de type `lpp` (*linear point pattern*), les principales mesures proposées sont les suivantes :

* nombre de points (`npoints`)
* nombre de points par unité de mesure (`intensity`)
* matrice des plus courtes distances entre points (`pairdist`)
* distance au plus proche voisin (`nndist`)
* identifiant du plus proche voisin (`nnwhich`)

La fonction `summary` permet là encore d'obtenir certaines de ces informations (nombre de points, nombre de points par unité), elle rappelle les caractéristiques principales du réseau (nombre de sommets, de liens et volume total) et enfin, elle fournit quartiles, médiane et moyenne des éventuels attributs numériques des points.

Le code suivant permet de calculer ces différents éléments sur le semis des épiciers et des bijoutiers à Paris.



::: {.cell}

```{.r .cell-code}
# semis des épiciers
# nombre de points et nombre de points par mètre
npoints(epiciers_ppp)
```

::: {.cell-output .cell-output-stdout}

```
[1] 1028
```


:::

```{.r .cell-code}
intensity(epiciers_ppp)
```

::: {.cell-output .cell-output-stdout}

```
[1] 2.371364e-05
```


:::

```{.r .cell-code}
# distance géographique (euclidienne) entre paires de points
pairdist(epiciers_ppp)[1:5, 1:5] # matrice symétrique
```

::: {.cell-output .cell-output-stdout}

```
         [,1]      [,2]      [,3]     [,4]     [,5]
[1,]    0.000 1422.0420 1801.8448 2484.028 2519.840
[2,] 1422.042    0.0000  935.2616 1768.920 2550.447
[3,] 1801.845  935.2616    0.0000 2669.784 1748.318
[4,] 2484.028 1768.9197 2669.7838    0.000 4314.051
[5,] 2519.840 2550.4468 1748.3184 4314.051    0.000
```


:::

```{.r .cell-code}
# distance géographique au plus proche voisin
nndist(epiciers_ppp)[1:5] 
```

::: {.cell-output .cell-output-stdout}

```
[1] 138.1796741   0.8380856  54.8029292 168.5354131  45.1379248
```


:::

```{.r .cell-code}
# identifiant du plus proche voisin
nnwhich(epiciers_ppp)[1:5] 
```

::: {.cell-output .cell-output-stdout}

```
[1] 110 263 990 847 429
```


:::

```{.r .cell-code}
# semis des bijouteries
npoints(bijoutiers_ppp)
```

::: {.cell-output .cell-output-stdout}

```
[1] 341
```


:::

```{.r .cell-code}
intensity(bijoutiers_ppp)
```

::: {.cell-output .cell-output-stdout}

```
[1] 1.275689e-05
```


:::
:::


-->
<p>La dernière étape consiste à intégrer dans le même objet le réseau linéaire et le semis de points à l’aide de la fonction <code>lpp</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>epiciers_lpp <span class="ot">&lt;-</span> <span class="fu">lpp</span>(<span class="at">X =</span> epiciers_ppp, </span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>                    <span class="at">L =</span> paris)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(epiciers_lpp)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Point pattern on linear network
1028 points
Linear network with 7237 vertices and 8730 lines
Total length 461193.7 units
Average intensity 0.002228998 points per unit length
Unmarked
Enclosing window: rectangle = [647640.1, 656138.1] x [6859014, 6865167] units</code></pre>
</div>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>bijoutiers_lpp <span class="ot">&lt;-</span> <span class="fu">lpp</span>(<span class="at">X =</span> bijoutiers_ppp, </span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">L =</span> paris)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(bijoutiers_lpp)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Point pattern on linear network
341 points
Linear network with 7237 vertices and 8730 lines
Total length 461193.7 units
Average intensity 0.0007393856 points per unit length
Unmarked
Enclosing window: rectangle = [647640.1, 656138.1] x [6859014, 6865167] units</code></pre>
</div>
</div>
<!-- inutile car vu sur le mini jeu de données  - Si l'on exécute la fonction `plot` sur un objet `lpp`, par défaut `linnet` propose un nombre de visualisations égal au nombre d'attributs des points, ces attributs étant appelés `marks`. Si je souhaite visualiser la répartion d'un attribut *Z* donné , j'utilise la syntaxe `plot(X, which.marks='Z')` -- le jeu de données utilisés ne comportant pas d'attributs pour les semis de points, cette option n'est pas mise en oeuvre ici. -->
<!-- j'ai déplacé le chunk de la densité pour le mettre dans la section sur les clusters -->
<p>Il est possible d’étudier un semis de points sur un réseau spatial selon les mêmes logiques qu’un semis dans un espace isotrope car diverses mesures ont été adaptées afin de considérer la structure du réseau <span class="citation" data-cites="okabe2012">(voir en particulier <a href="#ref-okabe2012" role="doc-biblioref">Okabe et Sugihara, 2012</a>)</span>.</p>
</section>
</section>
</section>
<section id="étudier-les-voisinages" class="level1">
<h1>Étudier les voisinages</h1>
<p>Différences d’approche entre fonction K et méthode du plus proche voisin</p>
<!--Questions selon qu'on étudie un ou deux semis de points-->
<section id="analyser-un-semis-de-points" class="level2">
<h2 class="anchored" data-anchor-id="analyser-un-semis-de-points">Analyser un semis de points</h2>
<p>Fonctions:</p>
<p>linearK (plus court chemin) et linearKinhom (pcc et non homogène)</p>
<p>linearKEuclid (distance euclidienne), linearKEuclidInhom (distance euclidienne et non homogène)</p>
<!-- ## Analyser la relation entre deux semis de points - on vire

A évoquer dans la conclusion générale



::: {.cell}

```{.r .cell-code}
# étudier un semis par rapport à un autre

crossdist(epiciers_ppp, bijoutiers_ppp)[1:5, 1:5] # shortest-path distances between pairs of ‘things’ taken from two different datasets.
```

::: {.cell-output .cell-output-stdout}

```
         [,1]     [,2]     [,3]     [,4]      [,5]
[1,] 1725.354 1189.305 1524.982 2715.270 1354.0494
[2,] 2198.302  680.736 1924.450 1321.922  243.2868
[3,] 3039.742 1575.508 2769.227 1735.172 1173.2468
[4,] 1721.839 1377.616 1569.930 1631.090 1569.6652
[5,] 4199.966 3024.996 3964.274 3468.329 2745.1090
```


:::

```{.r .cell-code}
nncross(epiciers_ppp, bijoutiers_ppp)[1:5,]  # given two point patterns X and Y, finds the nearest neighbour in Y of each point of X.
```

::: {.cell-output .cell-output-stdout}

```
      dist which
1 174.5787   257
2 105.8595    71
3 100.6455   122
4 248.2634   312
5 592.7533   163
```


:::
:::



Fonctions: linearKcross, linearKdot -->
</section>
</section>
<section id="modéliser-la-géographie-du-semis-de-points" class="level1">
<h1>Modéliser la géographie du semis de points</h1>
<section id="répartitions-aléatoires-des-points-sur-un-réseau-spatial" class="level2">
<h2 class="anchored" data-anchor-id="répartitions-aléatoires-des-points-sur-un-réseau-spatial">Répartitions aléatoires des points sur un réseau spatial</h2>
<p>Il est possible de comparer la répartition du semis de points étudié par rapport à une situation aléatoire sur un réseau. Plusieurs processus aléatoires déterminant à la fois le nombre et la distribution spatiale des points peuvent être simulés dans <code>spatstat.linnet</code>. Dans le premier cas (fonction <code>runiflpp()</code>), le semis de points est généré de façon aléatoire et la position des points est fonction de la seule longueur des voies du réseau : plus un tronçon est long, plus il est probable qu’il accueille un ou plusieurs points. Cette hypothèse n’est pas toujours la plus pertinente : si on prend l’exemple des accidents de voiture, on peut supposer qu’ils sont plus fréquents à mesure que le trafic augmente (et non la seule longueur des routes). Les deux options suivantes (<code>rpoislpp()</code> et <code>rlpp()</code>) permettent de générer un semis de points aléatoire lié à une intensité variable sur le réseau. <!-- j'espère que j'écris pas de bêtises, la différence entre rpois et rl n'est pas encore très nette pour moi --></p>
<p>Pour résumer, on peut simuler les trois semis suivants :</p>
<ul>
<li>Un processus aléatoire uniforme avec <code>runiflpp()</code>. La fonction génère <span class="math inline">n</span> points aléatoires, indépendamment et uniformément distribués, sur le réseau <span class="math inline">L</span>. La probabilité de tirer un tronçon <span class="math inline">Ls</span> du réseau dépend de sa longueur dans <span class="math inline">L</span>. Le point est généré selon une probabilité uniforme le long de <span class="math inline">Ls</span>.</li>
<li>Un processus poissonien avec la fonction <code>rpoislpp()</code>. Elle génère une réalisation du processus de Poisson avec une intensité spécifiée (paramètre <code>lambda</code>) sur le réseau <span class="math inline">L</span>.</li>
<li>Un processus aléatoire grâce à <code>rlpp()</code>, qui génère <span class="math inline">n</span> points aléatoires sur le réseau <span class="math inline">L</span> avec une densité de probabilité spécifiée (paramètre <code>f</code>). Cette dernière ne doit pas nécessairement être normalisée.</li>
</ul>
<p>Quelle que soit la fonction utilisée, il est possible de spécifier le nombre de simulations souhaitées grâce au paramètre <code>nsim</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># génération d'une simulation selon un processus de Poisson avec une intensité uniforme égale à la densité moyenne</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="fu">rpoislpp</span>(<span class="at">lambda =</span> <span class="fu">intensity</span>(bijoutiers_lpp), <span class="at">L =</span> paris, <span class="at">nsim =</span> <span class="dv">1</span>) <span class="co"># le nombre de points est variable</span></span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Point pattern on linear network
353 points
Linear network with 7237 vertices and 8730 lines
Enclosing window: rectangle = [647640.1, 656138.1] x [6859014, 6865167] units</code></pre>
</div>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># visualisation d'une simulation</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x =</span> <span class="fu">rpoislpp</span>(<span class="at">lambda =</span> <span class="fu">intensity</span>(bijoutiers_lpp), <span class="at">L =</span> paris, <span class="at">nsim =</span> <span class="dv">1</span>),</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">pch =</span> <span class="dv">15</span>, <span class="at">main =</span> <span class="cn">NULL</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-12-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Dans les cas de <code>rpoislpp()</code> et de <code>runiflpp()</code>, le paramètre <code>ex</code> permet d’intégrer un objet <code>lpp</code> afin de déterminer <span class="math inline">L</span>, ainsi que <span class="math inline">\lambda</span> et <span class="math inline">n</span>. La valeur par défaut de <span class="math inline">\lambda</span> est alors la densité moyenne des points du <code>lpp</code>, ou <span class="math inline">n</span> le nombre de points de l’objet <code>lpp</code>.</p>
</section>
<section id="mesurer-lécart-aux-distributions-aléatoires" class="level2">
<h2 class="anchored" data-anchor-id="mesurer-lécart-aux-distributions-aléatoires">Mesurer l’écart aux distributions aléatoires</h2>
<!-- à écrire -->
<p>Cas des bijoutiers, distances points aléatoires VS distances observées. Ici : proposition d’une boucle et de l’utilisation des packages de la famille du <code>tydiverse</code> à visée pédagogique, mais mieux de faire une fonction pour paralléliser le calcul matriciel si l’on a un nombre de simulations élevés (e.g.&nbsp;100) et un semis initial et un réseau plus important, et d’utiliser plutôt des packages comme <code>dtplyr</code> ou directement <code>data.table</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># génération de 10 simulations</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>bijoutiers_10sim <span class="ot">&lt;-</span> <span class="fu">runiflpp</span>(<span class="at">ex =</span> bijoutiers_lpp, <span class="at">nsim =</span> <span class="dv">10</span>)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="co"># calcul des distances entre les points simulés aléatoirement sur le réseau</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>list_simulated_dist <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(bijoutiers_10sim)) {</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># calculs des plus courts chemins sur réseau</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    dist_pi_p <span class="ot">&lt;-</span> spatstat.geom<span class="sc">::</span><span class="fu">pairdist</span>(<span class="at">X =</span> bijoutiers_10sim[[i]])</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    dist_pi_p[<span class="fu">upper.tri</span>(<span class="at">x =</span> dist_pi_p, <span class="at">diag =</span> <span class="cn">TRUE</span>)] <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    dist_pi_p <span class="ot">&lt;-</span> dist_pi_p <span class="sc">%&gt;%</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>      tibble<span class="sc">::</span><span class="fu">as_tibble</span>() <span class="sc">%&gt;%</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>      tibble<span class="sc">::</span><span class="fu">rowid_to_column</span>(<span class="at">var =</span> <span class="st">"Pi"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>      tidyr<span class="sc">::</span><span class="fu">pivot_longer</span>(<span class="at">cols =</span> <span class="sc">-</span>Pi, <span class="at">names_to =</span> <span class="st">"P"</span>, <span class="at">values_to =</span> <span class="st">"dist_pi_p"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>      dplyr<span class="sc">::</span><span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(dist_pi_p)) <span class="sc">%&gt;%</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>      dplyr<span class="sc">::</span><span class="fu">mutate</span>(<span class="at">P =</span> stringr<span class="sc">::</span><span class="fu">str_replace_all</span>(<span class="at">string =</span> P, <span class="at">pattern =</span> <span class="st">"V"</span>, <span class="at">replacement =</span> <span class="st">""</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>      dplyr<span class="sc">::</span><span class="fu">mutate</span>(<span class="at">type =</span> <span class="st">"simulation"</span>, <span class="at">n_sim =</span> i)</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>   list_simulated_dist[[i]] <span class="ot">&lt;-</span> dist_pi_p   </span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a><span class="co"># création d'un unique tableau et non d'une liste de tableaux</span></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>table_simulated_dist <span class="ot">&lt;-</span> <span class="fu">do.call</span>(<span class="at">what =</span> <span class="st">"rbind"</span>, <span class="at">args =</span> list_simulated_dist)</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>table_simulated_dist</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 579,700 × 5
      Pi P     dist_pi_p type       n_sim
   &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;      &lt;int&gt;
 1     2 1         4652. simulation     1
 2     3 1         3281. simulation     1
 3     3 2         6431. simulation     1
 4     4 1         2476. simulation     1
 5     4 2         3096. simulation     1
 6     4 3         5561. simulation     1
 7     5 1         7165. simulation     1
 8     5 2         5340. simulation     1
 9     5 3         5423. simulation     1
10     5 4         7468. simulation     1
# ℹ 579,690 more rows</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># calcul des distances entre les points observés des bijoutiers en 1839</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>dist_bijoutiers <span class="ot">&lt;-</span> spatstat.geom<span class="sc">::</span><span class="fu">pairdist</span>(<span class="at">X =</span> bijoutiers_lpp)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>dist_bijoutiers[<span class="fu">upper.tri</span>(<span class="at">x =</span> dist_bijoutiers, <span class="at">diag =</span> <span class="cn">TRUE</span>)] <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>dist_bijoutiers <span class="ot">&lt;-</span> dist_bijoutiers <span class="sc">%&gt;%</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as_tibble</span>() <span class="sc">%&gt;%</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rowid_to_column</span>(<span class="at">var =</span> <span class="st">"Pi"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_longer</span>(<span class="at">cols =</span> <span class="sc">-</span>Pi, <span class="at">names_to =</span> <span class="st">"P"</span>, <span class="at">values_to =</span> <span class="st">"dist_pi_p"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(dist_pi_p)) <span class="sc">%&gt;%</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">P =</span> stringr<span class="sc">::</span><span class="fu">str_replace_all</span>(<span class="at">string =</span> P, <span class="at">pattern =</span> <span class="st">"V"</span>, <span class="at">replacement =</span> <span class="st">""</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">type =</span> <span class="st">"observation"</span>, <span class="at">n_sim =</span> <span class="cn">NA</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Comparaison visuelle <!-- à commenter --></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>bijoutiers_ecart <span class="ot">&lt;-</span> table_simulated_dist <span class="sc">%&gt;%</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">bind_rows</span>(dist_bijoutiers)</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>bijoutiers_ecart <span class="sc">%&gt;%</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> dist_pi_p, <span class="at">color =</span> type)) <span class="sc">+</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_density</span>(<span class="at">linewidth =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-15-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Idem, cas des épiciers <!-- courbe ajoutée uniquement sans visualisation du code. A commenter --></p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-17-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Mesurer l’écart à une répartition aléatoire inhomogène selon l’inverse de la distance au centre. <!-- expliciter choix du centre : signification --></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>center <span class="ot">&lt;-</span> <span class="fu">st_read</span>(<span class="at">dsn =</span> <span class="st">"data/halles.gpkg"</span>)  <span class="co"># Les Halles considérées comme centre économique</span></span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Reading layer `notre-dame' from data source 
  `D:\jgravier\Sync\publications\linnet_point_pattern\data\halles.gpkg' 
  using driver `GPKG'
Simple feature collection with 1 feature and 2 fields
Geometry type: POINT
Dimension:     XY
Bounding box:  xmin: 651980.5 ymin: 6862655 xmax: 651980.5 ymax: 6862655
Projected CRS: RGF93 v1 / Lambert-93</code></pre>
</div>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>center_ppp <span class="ot">&lt;-</span> <span class="fu">as.ppp</span>(<span class="fu">st_geometry</span>(center))    <span class="co"># semis de points</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>center_lpp <span class="ot">&lt;-</span> <span class="fu">lpp</span>(<span class="at">X =</span> center_ppp, <span class="at">L =</span> paris) <span class="co"># semis de points sur le réseau</span></span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<!-- expliciter import de la fonction (vérifier encore une fois inexistance inverse de la distance) -->
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># import fonction</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="at">file =</span> <span class="st">"local-functions.R"</span>) <span class="co"># adaptation de spatstat.linnet::distfun.lpp()</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>f_dist2_center <span class="ot">&lt;-</span> <span class="fu">distfun.inverse.lpp</span>(<span class="at">X =</span> center_lpp) <span class="co"># création de la fonction d'intensité</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>f_dist2_center</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Function on linear network:
function (x, y = NULL, seg = NULL, tp = NULL, ...) 
{
    Y &lt;- as.lpp(x = x, y = y, seg = seg, tp = tp, L = L)
    d &lt;- nncross.lpp(Y, X, what = "dist", k = k)
    d &lt;- 1/d
    return(d)
}
&lt;bytecode: 0x000002644ea11118&gt;
&lt;environment: 0x000002645e797150&gt;
Function domain:
Linear network with 7237 vertices and 8730 lines
Enclosing window: rectangle = [647640.1, 656138.1] x [6859014, 6865167] units</code></pre>
</div>
</div>
<p>Répartition aléatoire inhomogène selon l’inverse de la distance au centre, i.e.&nbsp;plus on s’éloigne, plus la probabilité qu’un point soit simulé sur un tronçon diminue. <!-- à commenter --></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># simulation aléatoire de Poisson</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>dist2_center_bijoutiers <span class="ot">&lt;-</span> <span class="fu">rpoislpp</span>(<span class="at">lambda =</span> f_dist2_center, <span class="co"># fonction d'intensité</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">L =</span> paris,               <span class="co"># réseau</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">lmax =</span> <span class="fl">0.05</span>,</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">nsim =</span> <span class="dv">1</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Il est important de spécifier <code>lmax</code> si possible afin de diminuer le temps de calcul<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>lmax_known <span class="ot">&lt;-</span> <span class="fu">as.linim</span>(f_dist2_center)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>tab_lmax <span class="ot">&lt;-</span> <span class="fu">attr</span>(<span class="at">x =</span> lmax_known, <span class="at">which =</span> <span class="st">"df"</span>)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="fu">max</span>(tab_lmax<span class="sc">$</span>values)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Visualisation</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(dist2_center_bijoutiers, <span class="at">pch =</span> <span class="dv">15</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-22-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Calcul des distances entre les points simulés et le centre. Deux lpp avec <code>crossdist.lpp()</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># génération de 10 simulations (Poisson)</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>bijoutiers_10sim <span class="ot">&lt;-</span> <span class="fu">rpoislpp</span>(<span class="at">lambda =</span> f_dist2_center, <span class="co"># fonction d'intensité</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>                             <span class="at">L =</span> paris, <span class="co"># réseau</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>                             <span class="at">lmax =</span> <span class="fl">0.05</span>, <span class="co"># cf. plus bas</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>                             <span class="at">nsim =</span> <span class="dv">10</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in datagen.rpoisppOnLines(lambda, S, ...): lmax is not an upper bound
for lambda
Warning in datagen.rpoisppOnLines(lambda, S, ...): lmax is not an upper bound
for lambda
Warning in datagen.rpoisppOnLines(lambda, S, ...): lmax is not an upper bound
for lambda
Warning in datagen.rpoisppOnLines(lambda, S, ...): lmax is not an upper bound
for lambda
Warning in datagen.rpoisppOnLines(lambda, S, ...): lmax is not an upper bound
for lambda
Warning in datagen.rpoisppOnLines(lambda, S, ...): lmax is not an upper bound
for lambda
Warning in datagen.rpoisppOnLines(lambda, S, ...): lmax is not an upper bound
for lambda
Warning in datagen.rpoisppOnLines(lambda, S, ...): lmax is not an upper bound
for lambda
Warning in datagen.rpoisppOnLines(lambda, S, ...): lmax is not an upper bound
for lambda</code></pre>
</div>
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>list_simulated_dist <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(bijoutiers_10sim)) {</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  dist_pi_p <span class="ot">&lt;-</span> <span class="fu">crossdist.lpp</span>(<span class="at">X =</span> bijoutiers_10sim[[i]], <span class="at">Y =</span> center_lpp) <span class="co"># distances au plus court chemin entre deux lpp</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  dist_pi_p[<span class="fu">upper.tri</span>(<span class="at">x =</span> dist_pi_p, <span class="at">diag =</span> <span class="cn">TRUE</span>)] <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>  dist_pi_p <span class="ot">&lt;-</span> dist_pi_p <span class="sc">%&gt;%</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>    tibble<span class="sc">::</span><span class="fu">as_tibble</span>() <span class="sc">%&gt;%</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    tibble<span class="sc">::</span><span class="fu">rowid_to_column</span>(<span class="at">var =</span> <span class="st">"Pi"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>    tidyr<span class="sc">::</span><span class="fu">pivot_longer</span>(<span class="at">cols =</span> <span class="sc">-</span>Pi, <span class="at">names_to =</span> <span class="st">"P"</span>, <span class="at">values_to =</span> <span class="st">"dist_pi_p"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>    dplyr<span class="sc">::</span><span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(dist_pi_p)) <span class="sc">%&gt;%</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>    dplyr<span class="sc">::</span><span class="fu">mutate</span>(<span class="at">P =</span> stringr<span class="sc">::</span><span class="fu">str_replace_all</span>(<span class="at">string =</span> P, <span class="at">pattern =</span> <span class="st">"V"</span>, <span class="at">replacement =</span> <span class="st">""</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    dplyr<span class="sc">::</span><span class="fu">mutate</span>(<span class="at">type =</span> <span class="st">"simulation"</span>, <span class="at">n_sim =</span> i)</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>  list_simulated_dist[[i]] <span class="ot">&lt;-</span> dist_pi_p   </span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>table_simulated_dist <span class="ot">&lt;-</span> <span class="fu">do.call</span>(<span class="at">what =</span> <span class="st">"rbind"</span>, <span class="at">args =</span> list_simulated_dist)</span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a><span class="co"># calcul des distances entre les points observés des bijoutiers et le centre</span></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>dist_bijoutiers <span class="ot">&lt;-</span> <span class="fu">crossdist.lpp</span>(<span class="at">X =</span> bijoutiers_lpp, <span class="at">Y =</span> center_lpp)</span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>dist_bijoutiers[<span class="fu">upper.tri</span>(<span class="at">x =</span> dist_bijoutiers, <span class="at">diag =</span> <span class="cn">TRUE</span>)] <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>dist_bijoutiers <span class="ot">&lt;-</span> dist_bijoutiers <span class="sc">%&gt;%</span></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as_tibble</span>() <span class="sc">%&gt;%</span></span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rowid_to_column</span>(<span class="at">var =</span> <span class="st">"Pi"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_longer</span>(<span class="at">cols =</span> <span class="sc">-</span>Pi, <span class="at">names_to =</span> <span class="st">"P"</span>, <span class="at">values_to =</span> <span class="st">"dist_pi_p"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(dist_pi_p)) <span class="sc">%&gt;%</span></span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">P =</span> stringr<span class="sc">::</span><span class="fu">str_replace_all</span>(<span class="at">string =</span> P, <span class="at">pattern =</span> <span class="st">"V"</span>, <span class="at">replacement =</span> <span class="st">""</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">type =</span> <span class="st">"observation"</span>, <span class="at">n_sim =</span> <span class="cn">NA</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Visualisation</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>bijoutiers_ecart <span class="ot">&lt;-</span> table_simulated_dist <span class="sc">%&gt;%</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">bind_rows</span>(dist_bijoutiers)</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>bijoutiers_ecart <span class="sc">%&gt;%</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> dist_pi_p, <span class="at">color =</span> type)) <span class="sc">+</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_density</span>(<span class="at">linewidth =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"distance en mètres"</span>) <span class="sc">+</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">"KDE"</span>) <span class="sc">+</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-24-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<!-- ajouter ici ou en conclusion générale (?) : possibilité de considérer plusieurs points concomitamment (i.e. des pôles) -->
</section>
<section id="rechercher-et-analyser-les-clusters" class="level2">
<h2 class="anchored" data-anchor-id="rechercher-et-analyser-les-clusters">Rechercher et analyser les clusters</h2>
<!-- différence hot spot - cluster ? à creuser... -->
<p>La recherche de clusters ou de hot spots, soit des zones du réseau où la densité de points est plus forte qu’attendue, suppose de comparer la répartion observée à une répartition homogène où la probabilité de chaque tronçon d’accueillir un sommet serait fonction de sa seule longueur. La fonction <code>intensity</code> renvoie ce résultat (nombre moyen de points par unité de longueur). La visualisation de certaines mesures est intégrée par défaut dans le <em>package</em> et c’est notamment le cas pour la densité (nombre de points par unité de mesure du réseau).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co"># calcul de la densité de points par unité de réseau</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="co"># l'option finespacing n'est pas nécessaire pour un réseau de petite taille</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>densite_bij <span class="ot">&lt;-</span> <span class="fu">density.lpp</span>(<span class="at">x =</span> bijoutiers_lpp, </span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>                           <span class="at">finespacing =</span> <span class="cn">FALSE</span>, </span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>                           <span class="at">distance =</span> <span class="st">"path"</span>)</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>densite_epic <span class="ot">&lt;-</span> <span class="fu">density.lpp</span>(epiciers_lpp, </span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>                            <span class="at">finespacing =</span> <span class="cn">FALSE</span>, </span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>                            <span class="at">distance =</span> <span class="st">"path"</span>)</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a><span class="co"># option couleur (par défaut)</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(densite_epic)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-25-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co"># option épaisseur des liens du réseau</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x =</span> densite_bij, </span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">main =</span> <span class="st">"Densité de bijoutiers"</span>,</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>     <span class="at">style =</span> <span class="st">"width"</span>, </span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>     <span class="at">adjust =</span> <span class="fl">0.5</span>)  <span class="co"># contrôler épaisseur max</span></span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-25-2.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Comme dans de nombreuses visualisations proposées ces dernières années et contrairement aux règles classiques de la sémiologie graphique, plus la teinte est claire et plus la densité est élevée.</p>
<!-- découper, pas au bon endroit - garder un test et l'expliquer et signaler les autres tests possibles -->
<p>Il est possible de tester la densité des points en fontion d’une variable spatiale. L’opposition socio-spatiale ouest-est étant une donnée ancienne de Paris, on pourrait par exemple tester la densité des bijoutiers en fonction des x. Différents tests statistiques permettent ensuite de vérifier si le lien entre la densité du semis et la variable considérée est statistiquement significatif. Le test utilisé ci-dessous se base sur l’article de Mark Berman <span class="citation" data-cites="berman1986">(<a href="#ref-berman1986" role="doc-biblioref">1986</a>)</span>. La valeur <span class="math inline">Z_1</span>, appelée aussi test de Lawson-Waller en épidémiologie, mesure l’écart entre le semis observé et un semis suivant une répartition de Poisson. <!--; il est avec la fonction `cdf.test` d'utiliser les tests de Kolmogorov-Smirnov, Cramer-von Mises ou Anderson-Darling.--></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co"># bijoutiers plus présents à l'ouest ?</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="co"># test de Berman</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>btB <span class="ot">&lt;-</span> <span class="fu">berman.test</span>(bijoutiers_lpp, <span class="st">"x"</span>)</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>btB</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Berman Z1 test of CSR in linear network

data:  covariate 'x' evaluated at points of 'bijoutiers_lpp'
Z1 = 0.013408, p-value = 0.9893
alternative hypothesis: two-sided</code></pre>
</div>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(btB)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-26-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Comparer la courbe en pointillé (distribution attendue si le semis homogène était fonction de la variation de x) et la courbe noire (distribution observée) montre une plus faible présence aux extremités de la zone observée ; inversement, les bijoutiers sont davantage présents au centre de l’espace considéré (cf la pente de la courbe pleine). Les traits verticaux indiquent la médiane, en pointillés pour la répartition uniforme, en trait plein pour la répartition observée.</p>
<p>Si l’on observe une relation claire - ce qui n’est pas le cas ici - entre la densité du semis de points et une variable spatiale, il est possible de modéliser la relation entre les deux et d’étudier la qualité du modèle retenu. Le script suivant est donné uniquement à des fins pédagogiques, les résultats précédents ne montrant pas de relation significative entre semis et variable considérée.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co"># modéliser la relation entre présence de bijoutiers et axe ouest-est</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">lppm</span>(bijoutiers_lpp <span class="sc">~</span> x)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(fit)</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>lam <span class="ot">&lt;-</span> <span class="fu">predict</span>(fit, <span class="at">dimyx=</span><span class="dv">512</span>)</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(lam)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<!-- à commenter quand j'aurai compris... à mettre après hot spot car logique répartition uniforme et non aléatoire-->
<p>Caractériser la répartition du semis de points peut se fait à une échelle plus fine, celle du tronçon. Dans le cas de commerces, on pourrait par exemple supposer qu’il est plus intéressant d’être à proximité des intersections (visibilité et accessibilité plus grandes).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co"># épiciers davantage présents à proximité des intersections ?</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="co"># création du objet linfun (fonction d'un réseau linéaire)</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>alongE <span class="ot">&lt;-</span> <span class="fu">linfun</span>(<span class="cf">function</span>(x,y,seg,tp) { tp }, </span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">domain</span>(epiciers_lpp))</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="co"># relation entre semis de point et fonction</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>rhoalongE <span class="ot">&lt;-</span> <span class="fu">rhohat</span>(epiciers_lpp, alongE)</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(rhoalongE)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-28-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>L’axe des abscisses concerne les rues : 0 et 1 sont les deux extrémités de chaque rue et 0.5 le milieu. La ligne pointillée représente la distribution uniforme, la ligne noire la distribution observée, la zone en grisé étant l’intervalle de confiance. Les épiciers sont moins présents qu’attendu aux extrémités des rues.</p>
<!-- McSwiggan, G., Baddeley, A. and Nair, G. (2016) Kernel density estimation on a linear network. Scandinavian Journal of Statistics 44, 324–345. -->
</section>
</section>
<section id="intérêts-et-limites-du-package" class="level1">
<h1>Intérêts et limites du package</h1>
<p>Les méthodes d’analyse de semis de points sur réseaux planaires ne sont pas des méthodes statistiques stabilisées (voir par exemple une définition possible de la densité dans <span class="citation" data-cites="okabe2009">(<a href="#ref-okabe2009" role="doc-biblioref">Okabe et al., 2009</a>)</span> discutée dans <span class="citation" data-cites="mcswiggan2017">(<a href="#ref-mcswiggan2017" role="doc-biblioref">McSwiggan et al., 2017</a>)</span>) et les choix des développeurs de <code>spatstat.linnet</code> sont des choix possibles parmi d’autres ; ce ne sont pas nécessairement les plus pertinents pour une question de recherche donnée. Ceci pourrait expliquer le faible nombre de références présentes dans les descriptifs des fonctions. De manière générale, l’aide du seul package paraît insuffisante pour le prendre en main et il est nécessaire de la compléter avec les diverses publications des auteurs, notamment le chapitre 17 de <span class="citation" data-cites="baddeley2012">(<a href="#ref-baddeley2012" role="doc-biblioref">Baddeley et al., 2012</a>)</span><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>Une des limites concerne la non possibilité d’avoir des liens orientés sur le réseau : étudier certains phénomènes ponctuels en milieu urbain sans prendre en compte les sens de circulation automobile peut limiter l’intérêt des résultats. Il n’est pas non plus aisé de tester des hypothèses pourtant simples à formuler (lien entre semis de points et degré des sommets du réseau par exemple) tant il est nécessaire de jongler entre des objets de types différents. Créer ses propres fonctions est vite nécessaire pour tirer pleinement profit du package.</p>
<p><code>spatstat.linnet</code> n’est évidemment pas le seul package permettant ce type d’analyse (voir <a href="https://cran.rstudio.com/web/packages/intensitynet/index.html"><code>intensitynet</code></a> ou <a href="https://cran.rstudio.com/web/packages/spatgraphs/index.html"><code>spatgraphs</code></a>) mais il reste l’un des plus efficaces, surtout si on analyse des semis sur des réseaux de grande taille. À défaut d’être le plus simple à prendre en main, il semble l’un des plus rapides pour calculer les différents indicateurs et modèles disponibles. <!-- contrôler la doc de ces packages --></p>
</section>
<section id="pour-aller-plus-loin" class="level1">
<h1>Pour aller plus loin</h1>
<p>Le manuel le plus complet et le plus clair concernant l’analyse de semis de points sur un réseau est celui d’Okabe et Sugihara <span class="citation" data-cites="okabe2012">(<a href="#ref-okabe2012" role="doc-biblioref">2012</a>)</span> ; toutes les méthodes abordées par les auteurs ne peuvent être mises en oeuvre avec <code>linnet</code> (autocorrélation spatiale, modèle de Huff, etc.). L’article de Baddeley et Turner consacré à la première version du <em>package</em> <span class="citation" data-cites="baddeley2005">(<a href="#ref-baddeley2005" role="doc-biblioref">2005</a>)</span> gagne à être complété par le chapitre 17 de l’ouvrage de Baddeley <em>et al.</em> <span class="citation" data-cites="baddeley2012">(<a href="#ref-baddeley2012" role="doc-biblioref">2012</a>)</span>. Une mise à jour bibliographique récente est co-signé du même Baddeley <span class="citation" data-cites="baddeley2021">(<a href="#ref-baddeley2021" role="doc-biblioref">2021</a>)</span>.</p>
<!---Note : à voir, densité de Kernel sur réseau dans [-@okabe2009]--->
</section>
<section id="bibliography" class="level1 unnumbered">


</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">Bibliographie</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" data-line-spacing="2" role="list">
<div id="ref-baddeley2021" class="csl-entry" role="listitem">
Baddeley, A., Nair, G., Rakshit, S., McSwiggan, G. et Davies, T. M. (2021). Analysing point patterns on networks—A review. <em>Spatial Statistics</em>, <em>42</em>, 1‑35. <a href="https://doi.org/10.1016/j.spasta.2020.100435">https://doi.org/10.1016/j.spasta.2020.100435</a>
</div>
<div id="ref-baddeley2012" class="csl-entry" role="listitem">
Baddeley, A., Rubak, E. et Turner, R. (2012). <em>Spatial Point Pattern. Methodology and Applications with R</em>. CRC Press.
</div>
<div id="ref-baddeley2005" class="csl-entry" role="listitem">
Baddeley, A. et Turner, R. (2005). Spatstat: an R package for analyzing spatial point patterns. <em>Journal of statistical software</em>, <em>12</em>, 1‑42. <a href="https://doi.org/10.18637/jss.v012.i06">https://doi.org/10.18637/jss.v012.i06</a>
</div>
<div id="ref-berman1986" class="csl-entry" role="listitem">
Berman, M. (1986). Testing for spatial association between a point process and another stochastic process. <em>Journal of the Royal Statistical Society Series C: Applied Statistics</em>, <em>35</em>(1), 54‑62.
</div>
<div id="ref-mcswiggan2017" class="csl-entry" role="listitem">
McSwiggan, G., Baddeley, A. et Nair, G. (2017). Kernel density estimation on a linear network. <em>Scandinavian Journal of Statistics</em>, <em>44</em>(2), 324‑345. <a href="https://doi.org/10.1111/sjos.12255">https://doi.org/10.1111/sjos.12255</a>
</div>
<div id="ref-okabe2009" class="csl-entry" role="listitem">
Okabe, A., Satoh, T. et Sugihara, K. (2009). A kernel density estimation method for networks, its computational method and a <span>GIS</span>‐based tool. <em>International Journal of Geographical Information Science</em>, <em>23</em>(1), 7‑32. <a href="https://doi.org/10.1080/13658810802475491">https://doi.org/10.1080/13658810802475491</a>
</div>
<div id="ref-okabe2012" class="csl-entry" role="listitem">
Okabe, A. et Sugihara, K. (2012). <em>Spatial Analysis along Networks: Statistical and Computational Methods</em>. John Wiley &amp; Sons.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Glossaire et notes</h2>

<ol>
<li id="fn1"><p>Il s’agit plus précisément de l’extraction de la liste alphabétique de l’<em>Annuaire Général du Commerce</em> édité par Charles Lamy en 1839. Les informations plus précises sont inclues dans les métadonnées du dossier <em>data</em> (fichier <em>readme.md</em>).<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Si lambda est une fonction et <code>lmax</code> n’est pas spécifié dans <code>rpoislpp()</code>, alors la fonction génère environ 10,000 points le long des tronçons pour estimer <code>lmax</code>. Si <code>lmax</code> est spécifié avec une valeur trop élevée, le nombre de point générés aléatoirement (Poisson) avant d’appliquer la méthode de Lewis-Shedler pour accepter ou rejetter ces points générés va être très élevé et donc le temps de calcul allongé.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Ouvrage vendu à un tarif très élevé, visiter les archives d’Anna est recommandé.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Réutilisation</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.fr_fr">CC BY-SA 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{beauguitte2025,
  author = {Beauguitte, Laurent and Gravier, Julie},
  title = {Analyse de semis de points sur un réseau spatial avec R},
  journal = {Rzine},
  date = {2025-05-01},
  doi = {XXX},
  langid = {fr-FR},
  abstract = {L’analyse d’un semis de points sur un réseau désigne un
    ensemble de méthodes statistiques permettant de caractériser des
    événements ponctuels dans le temps et dans l’espace prenant place
    sur un réseau spatial planaire. Deux des sujets les plus traités
    dans la bibliographie sont les accidents de la circulation et les
    actes criminels commis dans l’espace public. Il est possible
    d’imaginer étudier d’autres thématiques plus ou moins ponctuelles
    dans le temps, qu’il s’agisse de l’offre commerciale dans un espace
    donné, du collage militant ou publicitaire, de la présence
    d’équipements dans l’espace public (bancs, toilettes), de présence
    de biotopes le long de cours d’eau, etc. Trois grands types de
    question sont généralement posés à ces données : (1) les points
    sont-ils significativement proches (ou éloignés) les uns des autres
    (étude du voisinage)\,? (2) Existe-t-il des lieux où la
    concentration des points est notable (hot spots)\,? (3) Quel modèle
    statistique est susceptible d’expliquer la géographie de ce semis de
    points\,? Ces trois questions sont abordées à l’aide du package R
    {[}spatstat.linnet{]}(https://cran.r-project.org/web/packages/spatstat.linnet/index.html)
    de la famille
    {[}spatstat{]}(https://cran.r-project.org/web/packages/spatstat/index.html).}
}
</code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">Veuillez citer ce travail comme suit&nbsp;:</div><div id="ref-beauguitte2025" class="csl-entry quarto-appendix-citeas" role="listitem">
Beauguitte, L. et Gravier, J. (2025). Analyse de semis de points sur un
réseau spatial avec R. <em>Rzine</em>. <a href="https://doi.org/XXX">https://doi.org/XXX</a>
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copié");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copié");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>